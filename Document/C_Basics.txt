C Bsics:
------------

Keywords : 32 reserved keyword in C Language.
         - int, float, char, double, long, 
           short, unsigned, signed, void,
           if, else, for, while, do, switch, 
           case, continue, break, struct, union,
           auto, const, default, enum, extern,
           goto, register, return, sizeof, static,
           typedef, volatile.

Identifiers : Identifier nothing but variable name, function name used by ourself to understand the flow of the logic and program.
 - Identifier can only have alphanumeric character (Letters & Digits) and underscore ( _ ).
 - The first character must be an aplphabet or underscore.
 - We cannot use keyword as Identifier.
 - Identifiers are case-sensitive.
 - Only the first 0-31 character are significant. 

Example : int Variable_name. here int - keyword, Variable_name - identifier.

Data Types :  
 - Primary Data Types (Build-in) : void, int, char, double and float.
 - Secondary Data Types (Derived) : Array, Reference and Pointers.
 - User defined Data Type : Structure, Union and Enumeration. 
-------------------------------------------------------------------------------------------------------------
Storage classes in C :
----------------------
     Type    - will declared || area || Initial value || Scope || life
	 -----------------------------------------------------------------
 1. auto     - only local, main memory, garbage value, Block scope, automatic
 2. register - only local, CPU register, garbage value, Block scope, automatic
 3. static   - loacl & global, main memory, Zero, Block or file scope, until program execution
 4. extern   - only global, primary memory, Zero, file scope, until program execution

/************** auto ********************/
#include<stdio.h>
int main()
{
    auto int a = 10;
    int b = 20;
	printf("Value of a = %d\n", a);
	printf("Value of b = %d", b);
	return 0;
}

Output: 
Value of a = 10
Value of b = 20

Note : Both  a and b declared as auto variables.
/****************************************/
/************ register ******************/
#include<stdio.h>
int main()
{
	register int i;
	for(i = 1; i<=10; i++)
	{
		printf("%d\n",i);
		printf("%d", &i); // will not work
	/* we can't use the pointer with register variable */
	}
	return 0;
}

Note : Required ->>> very frequent and very fast operation.
/*****************************************/
/************** Static ******************/
#include<stdio.h>
void increment()
{
	static int i;
	printf("%d", i);
	/* initial value of i is Zero */
	i++;
	printf("%d", i);
}
int main()
{
	function1();
	function2();
	function3();
	return 0;
}

Output:
1 2 3 

Note : static variables are created/initialized only once for first time.
/*****************************************/
/************** extern ******************/
// Variable.c 
extern int i;  // refer i in program1.called
void show()
{
	int j;
	j = i*2;
	printf("Value of j = %d\n", j);
}

//Progrram1.c 
#include <stdio.h>
#include "Variable.c" // link program variable.c
int i; // global declration
void show();
int main()
{
	i = 10;
	show();
	printf("Value of i = %d\n", i);
	return 0;
}

Output:
Value of j = 20
Value of i = 10

Note : The extern variable must be initialized as global variable
/*****************************************/

Pointers :
 - Pointers allow passing of arrays and strings to function more Efficiently.
 - using pointers able return more than one value from the function.
 - Save memory, Increase the processing speed and Reduce the length and complexity of a program.
 
 Reference Operator(&) - Expression &x returns the address of variable x.
 Deference Operator(*) - Expression *p returns the value of variable to which p points.
 
 Operator Precedence:
  - *ptr++ or *(ptr++) -> increment the pointer.
  - (*ptr)++  -> the value pointed by ptr is incremented by 1.


  Assertion in C:
    void assert(int expression);
  - assertion is triggered if the parameter passed into assert() is zero.
  - then the expression, sourcecode filename, and line number are sent to the standard error, 
    and then abort() function is called.
  - we can completely remove assertions at compile time using the preprocessor NDEBUG.
    #define NDEBUG
	
	
/***************************************************************************************************/